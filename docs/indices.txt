
19.1. All Elements: %model_name%::indices::all => %model_keys% so product::indices::all => set of product_keys;
19.2. Marking attributes as indices: attribute :name, String, :index => true, or attribute :name, String, :index => :unique. both would use the form: %model_name%::indices::%index_name%::%index_values% => %set of model keys%.
19.3. key indices (for relationships)
19.4. Number indices. %model_name%::indices::%index_name%::%index_values (integers or floats)% => %set of model keys%.
19.5. Date/Time indices, cast of unix timestamps when saving %model_name%::indices::%index_name%::%index_values (unix timestamps)% => %set of model keys%.
19.6. Sorted set of types for filtering. In the example below there is a 'types' set, this needs to be indexed so we can filter by it. 

h2. Using Sorted Sets for Filtering

Sorted set of types for filtering. In the example below there is a 'types' set, this needs to be indexed so we can filter by it. 

E.g.
<blockquote>
<code>
<pre>
class Product
  include Snowflake::Node

  attribute :name,        String
  attribute :code,        String
	attribute :supplier,		String

  set :types    # set of types, needs to be indexed
end
</pre>
</code>
</blockquote>

*Then*
bq. Product.all( :types => ['Multi-Function Printer', 'Photo Printers'] )

*Or*
bq. Product.all( :supplier => 'Brother', :types => ['Multi-Function Printer', 'Photo Printers'] )

*Basically this is just syntactic sugar for:*
bq. Product.all( :types => 'Multi-Function Printer', :type => 'Photo Printers' )

h3. How it could look

<blockquote>
<code>
<pre>
class Product
  include Snowflake::Node

  attribute :name,        String, :index => unique
  attribute :code,        String, :index => unique
	attribute :supplier,		String, :index => true

	# set of types, needs to be indexed
  set :types, :index => true
end				

Product:1 => name:foo, code:awesome1, supplier:Brother, :types => ['Multi-Function Printer', 'Photo Printers']
Product:2 => name:bar, code:awesome2, supplier:Brother, :types => ['Multi-Function Printer', 'Photo Printers', 'Colour Laser Printers']
Product:3 => name:baz, code:awesome3, supplier:Acme, :types => ['Thermal Printer']

Product::indices::all	=> SET<1, 2, 3>

Product::indices::name:foo	=> SET<1>
Product::indices::name:bar	=> SET<2>
Product::indices::name:baz	=> SET<3>

Product::indices::code:awesome1	=> SET<1>
Product::indices::code:awesome2	=> SET<2>
Product::indices::code:awesome3	=> SET<3>

Product::indices::supplier:Brother	=> SET<1, 2>
Product::indices::supplier:Acme	=> SET<3>

Product::indices::types:Multi-Function Printer	=> SET<1, 2>
Product::indices::types:Photo Printers	=> SET<1, 2>
Product::indices::types:Thermal Printer	=> SET<3>
Product::indices::types:Colour Laser Printers	=> SET<2>
</pre>
</code>
</blockquote>

*Then:*

bq. Product.all( :supplier => 'Brother', :types => ['Multi-Function Printer', 'Photo Printers'] ) 

*Via:*
<blockquote>
<code>
<pre>
def all( *options )
	# @todo extract pagination and limits from attribute filters

	if options.empty?
		# #all returns a Collection
		results = indices[:all].all
	else
		results = Collection.new
		
		options.each do |name, value|
			# The return value from #select must encapsulate the value and the index it was operating on.
			results = results & indices[name.to_sym].select( value )
		end
		
		results
	end

	# @todo paginate and limit the result

	# At this point the results collection holds the operation, but has not actually executed 
	# anything against the datastore yet	
	results
end
</pre>
</code>
</blockquote>

This wont become clear until I work out how to transform sets of operations into a pipelined series of Redis commands

h2. Simple Filtering

*Assuming:*
<blockquote>
<code>
<pre>
Product:1 => name:foo, code:awesome1, supplier:Brother, :types => ['Multi-Function Printer', 'Photo Printers']
Product:2 => name:bar, code:awesome2, supplier:Brother, :types => ['Multi-Function Printer', 'Photo Printers', 'Colour Laser Printers']
Product:3 => name:baz, code:awesome3, supplier:Acme, :types => ['Thermal Printer']

Product:1 => name:foo, code:awesome1, supplier:Brother, :types => ['Multi-Function Printer', 'Photo Printers']
Product:2 => name:bar, code:awesome2, supplier:Brother, :types => ['Multi-Function Printer', 'Photo Printers', 'Colour Laser Printers']
Product:3 => name:baz, code:awesome3, supplier:Acme, :types => ['Thermal Printer']

Product::indices::all	=> SET<1, 2, 3>

Product::indices::name:foo	=> SET<1>
Product::indices::name:bar	=> SET<2>
Product::indices::name:baz	=> SET<3>

Product::indices::code:awesome1	=> SET<1>
Product::indices::code:awesome2	=> SET<2>
Product::indices::code:awesome3	=> SET<3>

Product::indices::supplier:Brother	=> SET<1, 2>
Product::indices::supplier:Acme	=> SET<3>

Product::indices::types:Multi-Function Printer	=> SET<1, 2>
Product::indices::types:Photo Printers	=> SET<1, 2>
Product::indices::types:Thermal Printer	=> SET<3>
Product::indices::types:Colour Laser Printers	=> SET<2>
</pre>
</code>
</blockquote>

*And:*
bq.	products = Product.all( :supplier => 'Foo', :code => 'awesome1' )

*We Eval:*
<blockquote>
<code>
<pre>
Collection( AndOperation )
Collection( AndOperation( Operand(:supplier, 'Brother'), Operand(:code, 'awesome1') ) )
</pre>
</code>
</blockquote>

*As:*
<blockquote>
<code>
<pre>
SUNIONSTORE TMP_KEY, Product::indices::supplier::Foo, Product::indices::code::awesome1
SMEMBERS TMP_KEY
DEL TMP_KEY
</pre>
</code>
</blockquote>

h2. Complex Filtering

*Assuming:*
	The same as previous

*And:*
bq.	products = Product.all( :supplier => 'Foo', :code => 'awesome1' ).or( :types => ['Multi-Function Printer', 'Photo Printers'] )

*We Eval:*
<blockquote>
<code>
<pre>
Collection( OrOperation )
Collection( 
					  OrOperation( 
								AndOperation, Operand(:types, ['Multi-Function Printer', 'Photo Printers']) 
							) 
					)
Collection(
						OrOperation( 
								AndOperation( Operand(:supplier, 'Foo'), Operand(:code, 'Bar') ),
								OrOperation( Operand(:types, 'Multi-Function Printer'), Operand(:types, 'Photo Printers')  )
							)
					)
</pre>
</code>
</blockquote>

*As:*
<blockquote>
<code>
<pre>
SUNIONSTORE TMP_KEY1, Product::indices::supplier::Foo, Product::indices::code::awesome1
SUNIONSTORE TMP_KEY2, Product::indices::types:Multi-Function Printer, Product::indices::types:Photo Printers	
SINTERSTORE TMP_KEY3 TMP_KEY1 TMP_KEY2
SMEMBERS TMP_KEY3
DEL TMP_KEY1
DEL TMP_KEY2
DEL TMP_KEY3
</pre>
</code>
</blockquote>

h2. Actual Use Cases

Indices and Operands are very similar. The main difference is that Indices are designed to 
retrieve results immediately, and Operands are designed to pipeline their retrieval commands
with other operands/operations commands to be executed in bulk.

Perhaps Operands are just sets of data to perform Operations on. So an Operand wouldn't 
understand if it was the set of all Products, or a specific set of ids for a specific index
value (say Product::indices::supplier::brother). But Indices are higher level than Operands
and have that context. This means that an Index will most likely be operating on one or more
Operands.

h3. Get All Products

We want to achieve this:
bq. products = Product.all

This can be answered using Operands and a Collection:
bq. all_products = Collection.new( Operand.new(Product, 'all') )

h3. Get Products Using a Simple Filter

We want to achieve this:
bq. products = Product.all( :supplier => 'Foo', :code => 'awesome1' )

This can be answered using a Collection, with two Operands OR together:
bq. Collection.new( Operand.new(Product, 'supplier', 'Foo') ).or( Operand.new(Product, 'code', 'awesome1') )

h3. Get Products Using a Simple Filter

We want to achieve this:
bq. products = Product.all( :supplier => 'Foo', :code => 'awesome1' ).or( :types => ['Multi-Function Printer', 'Photo Printers'] )

This can be answered using a Collection, with two Operands OR together:

<blockquote>
<code>
<pre>
foo_or_awesome1 = Collection.new( OrOperation.new( Operand.new(Product, 'supplier', 'Foo'), Operand.new(Product, 'code', 'awesome1') ) )
multi_function_or_photo_printers = Collection.new( OrOperation.new( Operand.new(Product, 'type', 'Multi-Function Printer'), Operand.new(Product, 'type', 'Photo Printers') ) )
Collection.new( foo_or_awesome1 ).or( multi_function_or_photo_printers )
</pre>
</code>
</blockquote>

h2. Modifying Indices

The Index class must understand which operands (or maybe it should insert the data directly) 
to update. For a simple case, like the 'all' index, it only  needs to update a single set.
The majority of cases will not be simple, and will involve updating multiple sets. So if
the 'supplier' field has an index and a particular Element modifies it from 'Cannon' to 
'Brother' the following will need to be executed:

<blockquote>
<code>
<pre>
self.indices[:supplier].modify(self.key, 'Cannon', 'Brother')
</pre>
</code>
</blockquote>

*Or at a low level*
<blockquote>
<code>
<pre>
srem ModelName::indices::supplier::Cannon product_id
sadd ModelName::indices::supplier::Brother product_id
</pre>
</code>
</blockquote>



