
h2. TODO

19. Indices: sorted sets of ids?
	19.1. DONE All Elements: %model_name%::indices::all => %model_keys% so product::indices::all => set of product_keys;
	19.2. DONE Marking attributes as indices: attribute :name, String, :index => true. it would use the form: %model_name%::indices::%index_name%::%index_values% => %set of model keys%.
	19.3. Marking attributes as unique indices: attribute :name, String, :index => :unique...
	19.4. key indices (for relationships)
	19.5. DONE Number indices. %model_name%::indices::%index_name%::%index_values (integers or floats)% => %set of model keys%.
	19.6. DONE Date/Time indices, cast of unix timestamps when saving %model_name%::indices::%index_name%::%index_values (unix timestamps)% => %set of model keys%.
	19.7. Indexing multiple values for a single key in a single Attribute. In the example below there is a 'types' set, this needs to be indexed so we can filter by it. 
				E.g.
					class Product
					  include Snowflake::Node

					  attribute :name,        String
					  attribute :code,        String
						attribute :supplier,		String
			
					  set :types    # set of types, needs to be indexed
					end

				Then
					Product.all( :types => ['Multi-Function Printer', 'Photo Printers'] )
				Or
					Product.all( :supplier => 'Brother', :types => ['Multi-Function Printer', 'Photo Printers'] )

				Basically this is just syntactic sugar for:
					Product.all( :types => 'Multi-Function Printer', :type => 'Photo Printers' )

	19.8. Sorted set of types for filtering. In the example below there is a 'types' set, this needs to be indexed so we can filter by it. 

				E.g.
					class Product
					  include Snowflake::Node

					  attribute :name,        String
					  attribute :code,        String
						attribute :supplier,		String

						attribute :cost,				Float

					  set :types    # set of types, needs to be indexed
					end

				Then
					Product.all( :cost => 10.0 )
				Or
					Product.all( :cost => 10.0..20.0 )

				For this example we need a sorted set index for the cost attribute, we can then use ZRANGEBYSCORE to retrieve a range of results.

				Some attribute type should have a sorted set index created for them, others shouldn't. Here's the list of those that definitely should:
				* Integer
				* Float
				* DateTime

				And some extended types that should
				* Counter

				I don't want to hardcode which attributes need this. But I also don't want to 
				create a whole pile of extra maintenance work for users. It would be nice to have 
				a method that can dump an index config for an Array of Elements.

				So...
				Snowflake::Indices.dump_definition( Product, User ) => YAML output is as follows:
				# Each index can be defined using just a name, or a hash that contains a name
				# and a type. If you only provide a name the Indexer will assume that the date 
				# is a String.
				elements:
				  - name: Product
				    indices:
							name: String
							permalink: String
							brand: String
							web_shops: Set
							type: Enum
							status: Enum
							sku: String
				  - name: User
				    indices:
							name: String
							age: Integer
							mood: String
							tags: Set

				Which can then be read by the indexer, and it can use the Type hints to work out
				what kind of Indices to create for each attribute.

	19.9. Some way of saying all that *don't* match some value.
	19.10. Refactor and DRY up Indices and Index Management
					This mirrors a similar piece in #attribute in attributes.rb. The index stuff 
					is beginning to feel like a big ball of mud. We instantiate the Index object
					in custom_attributes.rb and attributes.rb, then add index management methods 
					(add to, delete from, modify) in Index, and element specific Index management 
					in Indices.rb (respond to Element workflow and call Index management methods 
					accordingly ), then we also have index management methods for custom attributes 
					which resides in the custom attribute classes themselves. It touches way too 
					many pieces of code.

			 One possibility is to decouple Indices from the core and wait for keys that are 
 			 associated with indices to be modified (using Redis' PUB/SUB), then update the 
			 indices. This does mean that the code that maintains the indices must be run as
			 a separate program, probably some kind of long-running daemon.
	19.11. When reading many elements we should send the hgetall's pipelined at once. So Product.all should get the ids then send all hgetalls as one pipelined command
	19.12. Some tidy way of clearing and rebuilding all indices, without needing to also 
				 rebuild the data. Maybe:
						Snowflake::Indices.teardown!
						Snowflake::Indices.build!
					And possible more specifically:
						Snowflake::Indices.teardown!(Product, User)
						Snowflake::Indices.build!(Product, User)

					Although I not totally happy with the method names (teardown and build). 
					"Snowflake::Indices" could be a good place to put other Index management bits,
					some ways of getting index statistics, total usage, and helpers for peeking at
					the index data would be really handy for debugging.

21. Relationships. Create a relationship model that includes Element, it can have properties but no relationships. mate /Users/rollyfordham/.rvm/gems/ruby-1.9.2-head/gems/rgl-0.4.0/
22. Search through Sphinx/Xapian/Solr: handy full-text node search. http://xapian.org/features. Xapian supports indexing PDFs, Word docs, etc. Need to provide a way to easily dynamicise what gets indexed and how.
		- Convert word docs: http://linux.die.net/man/1/antiword
		- Convert PDF: http://en.wikipedia.org/wiki/Pdftotext
		- http://moinmo.in/HelpOnXapian
23. auto-populated created_at and updated_at.
24. creation of groups based on the union of other networks, can use pub/sub to get notification of when the inner groups change then recalculate the outer group.
25. after update hooks should be passed the fields that have been updated and the original values.
26. Observer classes
27. Can we defined types on non-predefined?
28. after filters (and before?) using pub/sub?
29. Add an explicit find hooks
			define_model_callbacks :find, :only => :after
30. Add an Identity Map, I'm not convinced we need it but, if we do, this could be helpful http://github.com/swistak/weakling
33. Hook intro Rails instrumentation
34. Treetop grammar for searching indices, just because it would be fun to create it :-)
36. Consider using ZSets as an option for Indices, the sort criteria could be the Edge weight.
38. Add a reference Custom Attribute: "reference :superceeded_by,  Product". Also allow some form of basic validation for references: "reference :related_service,   Product, :category => :service"
40. Support Time Zones in the DateTime attribute
41. Add a :store_default_values option to #attribute, default it to false
43. Add a reference attribute? reference :related_service, Product, :type => :service. The related class can be anything ActiveModel compatible.
46. Embedded document support
47. Add better query syntax for more complex queries. nicer_queries.rb (docs/experiments/nicer_queries.rb) 
		might be a good start, although it can only AND operators, OR must be handled separately.

		Some example syntax is below:

		query = Person.all { name != 'bob' && mood == 'awesome' && age > 25  && age <= 60 }
		puts query.length
		query.each do |person|
			puts person.name
		end
		
		NOTE: We can only overload operators like '!=' on Ruby 1.9.x, but I was thinking of
		dropping support for 1.8.x in the short term anyway. It's only really needed for short
		term compatibility.
	http://github.com/knowtheory/dm-sugar-glider
	http://github.com/dkubb/veritas
	

h2. DONE 

1. Dirty tracking, only update modified fields.
2. More powerful defaults, we should accept a proc/lambda
3. If no key field is specific automagically create one called 'id' that gets a 128 bit UUID.
4. When the key field is changed we should also send a RENAME command (requires Dirty tracking)
5. Validation
6. Errors
7. ActiveModel support
8. Ruby 1.9.2 support (well my tests pass anyways)
9.  Create an Element object, it's the common functionality that both Node and Edge require.
11. The hash properties are never saved a property as a time, the entire hash is saved as once. All other properties can be modified using atomic operations. 
					I should split the dsl into hash properties and non-hash properties. Hash properties use the normal modify and bulk save workflow as Datamapper. Non-hash properties
					allow operations to be performed and serialised immediately.
12. We need to allow dynamic hash fields, i.e. ones that were not predefined using the property method. The use cases for both are:
		* Predefined: expected fields, can defined validation/etc
		* Non-predefined: unexpected fields. Dynamically created.
13. Some way for plugins to register registered attribute names: schema, ??
14. Rename the project
15. Tasks, Generators, and connection handling for Rails 3. http://railsdispatch.com/posts/how-rails-3-enables-more-choices-part-1
16. Add explicit validation and initialize hooks
			define_model_callbacks :validation, :save, :create, :update, :destroy, :only => [ :before, :after ]
			define_model_callbacks :initialize, :only => :after
17. Migrations. Just because we are schemaless on the DB side doesn't mean evolving data needs won't affect us. Create a Schema model, each element should have one.
		Then rake scripts to do common migration tasks and a dsl to write the actual migrations. Add "schema" as a restricted Attribute name.
18. Compatibility with ActiveModel::Dirty
20. Retrieve random element: using http://code.google.com/p/redis/wiki/SrandmemberCommand
31. Remove the Element namespace (it was only needed while I was refactoring the old Node code) and shuffle everything down one level
32. Include CustomAttributes in serialisation. ActiveRecord has an example of doing this.
35. Duplicating the key generating stuff in the Indexer ( where we don't have the context 
		to say ElementModel.key_for( ... ) ) leads to brittleness, and bugs when modifying key 
		generation. Refactor all the key_for/meta_key_for bits out into a Naming module. Then
		we can use that Naming module in the Indexer.
37. Add a DateTime Attribute
39. Add a Enum Attribute: "attribute :type, Enum[:service, :hardware, :software, :training]"
42. Support :required => true on attribute definitions, basically it should just add validates_presence_of attributename
44. [[REVERTED: THIS CAUSED WAY TO MANY PROBLEMS]] DON'T store attribute defaults in the data area, but DO store them in the indices.
45. Add a logger to Snowflake
	45.1. The logger should default to STDOUT
	45.2. If the log level is debug it should "explain_analyse" every query